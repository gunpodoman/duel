<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Core Artillery: Ultimate</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --p1-color: #3b82f6; --p2-color: #ef4444;
            --accent: #f59e0b; --bg-dark: #0f172a;
        }
        body { margin: 0; overflow: hidden; background: var(--bg-dark); font-family: 'Segoe UI', system-ui, sans-serif; touch-action: none; color: white; }
        
        /* 로딩 및 초대 화면 */
        #overlay { position: fixed; inset: 0; background: radial-gradient(circle, #1e293b 0%, #000 100%); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; transition: 0.5s; }
        .card { background: rgba(255,255,255,0.05); padding: 40px; border-radius: 30px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(10px); text-align: center; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        .btn { padding: 15px 40px; background: var(--accent); border: none; border-radius: 50px; font-weight: bold; font-size: 18px; cursor: pointer; color: #000; transition: 0.3s; box-shadow: 0 0 20px rgba(245,158,11,0.4); }
        .btn:hover { transform: scale(1.05); background: #ffb833; }
        .btn:disabled { background: #444; color: #888; box-shadow: none; cursor: wait; }

        /* 게임 UI */
        #game-ui { position: absolute; inset: 0; pointer-events: none; display: none; }
        .status-bar { position: absolute; top: 20px; width: 100%; display: flex; justify-content: space-around; padding: 0 20px; box-sizing: border-box; }
        .hp-card { background: rgba(0,0,0,0.5); padding: 10px 20px; border-radius: 15px; border-bottom: 4px solid transparent; width: 180px; }
        .hp-bg { width: 100%; height: 12px; background: #334155; border-radius: 6px; margin-top: 8px; overflow: hidden; }
        .hp-fill { height: 100%; transition: width 0.5s cubic-bezier(0.17, 0.67, 0.83, 0.67); }
        
        #wind-box { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); text-align: center; background: rgba(0,0,0,0.3); padding: 5px 20px; border-radius: 20px; }
        #turn-msg { position: absolute; top: 100px; width: 100%; text-align: center; font-size: 32px; font-weight: 900; text-transform: uppercase; letter-spacing: 2px; text-shadow: 0 0 20px rgba(255,255,255,0.5); opacity: 0; transition: 0.3s; }
        #turn-msg.show { opacity: 1; transform: translateY(10px); }
    </style>
</head>
<body>

<div id="overlay">
    <div class="card">
        <h1 style="margin:0 0 10px 0; letter-spacing: -1px;">CANNON DUEL</h1>
        <p style="color: #94a3b8; margin-bottom: 30px;">최고의 포격수를 가리는 대결</p>
        <button id="invite-btn" class="btn" onclick="copyInvite()" disabled>초대 링크 생성 중...</button>
    </div>
</div>

<div id="game-ui">
    <div class="status-bar">
        <div class="hp-card" style="border-color: var(--p1-color)">
            <span style="font-size:12px; color:#94a3b8">PLAYER 1</span>
            <div class="hp-bg"><div id="hp-p1" class="hp-fill" style="width:100%; background:var(--p1-color)"></div></div>
        </div>
        <div id="wind-box">
            <div id="wind-text" style="font-size:14px; font-weight:bold">WIND: 0</div>
            <div id="wind-arrow" style="font-size:20px">→</div>
        </div>
        <div class="hp-card" style="border-color: var(--p2-color); text-align: right;">
            <span style="font-size:12px; color:#94a3b8">PLAYER 2</span>
            <div class="hp-bg"><div id="hp-p2" class="hp-fill" style="width:100%; background:var(--p2-color)"></div></div>
        </div>
    </div>
    <div id="turn-msg">YOUR TURN</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- 설정 및 상수 ---
    const GRAVITY = 0.25;
    const TANK_SIZE = 35;
    let canvas, ctx, w, h;
    let myId, conn, isHost = false, iAmP1 = false;
    let particles = [];

    // --- 게임 상태 ---
    let state = {
        terrain: [],
        p1: { x: 0, y: 0, hp: 100, color: '#3b82f6', angle: 0 },
        p2: { x: 0, y: 0, hp: 100, color: '#ef4444', angle: 0 },
        turn: 1,
        wind: 0,
        ball: null,
        gameOver: false
    };

    // --- 초기화 및 네트워크 ---
    const peer = new Peer(null, { config: {'iceServers': [{ url: 'stun:stun.l.google.com:19302' }]} });
    
    peer.on('open', id => {
        myId = id;
        document.getElementById('invite-btn').disabled = false;
        document.getElementById('invite-btn').innerText = "초대 링크 복사";
        if(window.location.hash) connectTo(window.location.hash.substring(1));
    });

    peer.on('connection', c => { conn = c; isHost = true; iAmP1 = true; setupConn(); });

    function copyInvite() {
        navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}#${myId}`);
        alert("링크가 복사되었습니다! 상대에게 보내세요.");
    }

    function connectTo(tid) { conn = peer.connect(tid); isHost = false; iAmP1 = false; setupConn(); }

    function setupConn() {
        conn.on('open', () => {
            document.getElementById('overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('overlay').style.display = 'none';
                document.getElementById('game-ui').style.display = 'block';
                initCanvas();
                if(isHost) initGame();
                requestAnimationFrame(loop);
            }, 500);
        });
        conn.on('data', data => {
            if(data.type === 'SYNC') { state = data.state; updateUI(); }
            if(data.type === 'FIRE' && isHost) fire(data.angle, data.power);
            if(data.type === 'BOOM') createExplosion(data.x, data.y, data.color);
        });
    }

    function initCanvas() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        resize();
        window.addEventListener('resize', resize);
        setupInput();
    }

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        if(isHost && state.terrain.length === 0) initGame();
    }

    // --- 게임 로직 ---
    function initGame() {
        state.terrain = [];
        let currH = h * 0.7;
        for(let x = 0; x <= w + 40; x += 40) {
            currH += (Math.random() - 0.5) * 100;
            currH = Math.max(h * 0.4, Math.min(h * 0.85, currH));
            state.terrain.push({x, y: currH});
        }
        state.p1.x = w * 0.15; state.p1.y = getTerrainY(state.p1.x);
        state.p2.x = w * 0.85; state.p2.y = getTerrainY(state.p2.x);
        state.wind = (Math.random() - 0.5) * 0.3;
        sync();
    }

    function getTerrainY(x) {
        for(let i=0; i < state.terrain.length - 1; i++) {
            if(x >= state.terrain[i].x && x <= state.terrain[i+1].x) {
                let ratio = (x - state.terrain[i].x) / (state.terrain[i+1].x - state.terrain[i].x);
                return state.terrain[i].y * (1 - ratio) + state.terrain[i+1].y * ratio;
            }
        }
        return h;
    }

    function fire(angle, power) {
        if(state.ball || state.gameOver) return;
        const p = state.turn === 1 ? state.p1 : state.p2;
        state.ball = { x: p.x, y: p.y - 20, vx: Math.cos(angle) * power, vy: Math.sin(angle) * power };
        sync();
    }

    function sync() { if(isHost) conn.send({type: 'SYNC', state}); updateUI(); }

    // --- 렌더링 엔진 ---
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function update() {
        if(!isHost) return;
        if(state.ball) {
            state.ball.vx += state.wind;
            state.ball.vy += GRAVITY;
            state.ball.x += state.ball.vx;
            state.ball.y += state.ball.vy;

            let groundY = getTerrainY(state.ball.x);
            if(state.ball.y > groundY || state.ball.x < 0 || state.ball.x > w) {
                // 충돌 판정
                checkHit(state.ball.x, state.ball.y);
                const boomData = {type: 'BOOM', x: state.ball.x, y: state.ball.y, color: state.turn === 1 ? state.p1.color : state.p2.color};
                createExplosion(boomData.x, boomData.y, boomData.color);
                conn.send(boomData);
                
                state.ball = null;
                state.turn = state.turn === 1 ? 2 : 1;
                state.wind = (Math.random() - 0.5) * 0.3;
                sync();
            }
        }
    }

    function checkHit(bx, by) {
        const target = state.turn === 1 ? state.p2 : state.p1;
        const dist = Math.sqrt((bx - target.x)**2 + (by - target.y)**2);
        if(dist < TANK_SIZE + 10) {
            target.hp = Math.max(0, target.hp - 35);
            if(target.hp <= 0) state.gameOver = true;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, w, h);
        
        // 1. 배경 그라데이션
        let sky = ctx.createLinearGradient(0, 0, 0, h);
        sky.addColorStop(0, '#0f172a'); sky.addColorStop(1, '#1e293b');
        ctx.fillStyle = sky; ctx.fillRect(0, 0, w, h);

        // 2. 지형 렌더링
        ctx.beginPath();
        ctx.moveTo(0, h);
        state.terrain.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(w, h);
        let ground = ctx.createLinearGradient(0, h*0.5, 0, h);
        ground.addColorStop(0, '#334155'); ground.addColorStop(1, '#0f172a');
        ctx.fillStyle = ground; ctx.fill();
        ctx.strokeStyle = '#475569'; ctx.lineWidth = 2; ctx.stroke();

        // 3. 탱크 렌더링
        drawTank(state.p1, 1);
        drawTank(state.p2, 2);

        // 4. 포탄 렌더링
        if(state.ball) {
            ctx.fillStyle = 'white';
            ctx.shadowBlur = 15; ctx.shadowColor = 'white';
            ctx.beginPath(); ctx.arc(state.ball.x, state.ball.y, 5, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        // 5. 가이드라인 및 조준 UI
        if(input.active && state.turn === (iAmP1 ? 1 : 2) && !state.ball) {
            drawGuide();
        }

        // 6. 파티클(폭발)
        particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.alpha -= 0.02;
            ctx.fillStyle = p.color.replace(')', `, ${p.alpha})`).replace('rgb', 'rgba');
            ctx.fillRect(p.x, p.y, p.size, p.size);
            if(p.alpha <= 0) particles.splice(i, 1);
        });
    }

    function drawTank(p, num) {
        ctx.save();
        ctx.translate(p.x, p.y);
        
        // 몸체
        ctx.fillStyle = p.color;
        ctx.beginPath(); ctx.roundRect(-20, -10, 40, 15, 5); ctx.fill();
        // 포탑
        ctx.beginPath(); ctx.arc(0, -10, 10, Math.PI, 0); ctx.fill();
        // 포신 (회전)
        ctx.strokeStyle = p.color; ctx.lineWidth = 6; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(0, -12);
        let barrelLen = 25;
        let ang = (num === 1) ? state.p1.angle : state.p2.angle;
        if(!ang) ang = (num === 1 ? -0.5 : 3.6);
        ctx.lineTo(Math.cos(ang) * barrelLen, Math.sin(ang) * barrelLen - 12);
        ctx.stroke();

        ctx.restore();
    }

    function drawGuide() {
        const p = iAmP1 ? state.p1 : state.p2;
        const dx = input.startX - input.currX;
        const dy = input.startY - input.currY;
        const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 25);
        const angle = Math.atan2(dy, dx);
        
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        let tx = p.x, ty = p.y - 20, tvx = Math.cos(angle) * power, tvy = Math.sin(angle) * power;
        for(let i=0; i<30; i++) {
            ctx.lineTo(tx, ty);
            tvx += state.wind; tvy += GRAVITY; tx += tvx; ty += tvy;
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function createExplosion(x, y, color) {
        for(let i=0; i<20; i++) {
            particles.push({
                x, y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                size: Math.random()*5+2, alpha: 1, color: color === '#3b82f6' ? 'rgb(59, 130, 246)' : 'rgb(239, 68, 68)'
            });
        }
    }

    // --- 입력 조작 ---
    let input = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };
    function setupInput() {
        canvas.addEventListener('pointerdown', e => {
            if(state.turn !== (iAmP1 ? 1 : 2) || state.ball) return;
            input.active = true;
            input.startX = input.currX = e.clientX;
            input.startY = input.currY = e.clientY;
        });
        window.addEventListener('pointermove', e => {
            if(!input.active) return;
            input.currX = e.clientX; input.currY = e.clientY;
            // 각도 실시간 업데이트 (포신 회전용)
            const p = iAmP1 ? state.p1 : state.p2;
            p.angle = Math.atan2(input.startY - input.currY, input.startX - input.currX);
        });
        window.addEventListener('pointerup', () => {
            if(!input.active) return;
            input.active = false;
            const dx = input.startX - input.currX, dy = input.startY - input.currY;
            const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 25);
            if(power > 2) {
                if(isHost) fire(state.p1.angle, power);
                else conn.send({type: 'FIRE', angle: state.p2.angle, power});
            }
        });
    }

    function updateUI() {
        document.getElementById('hp-p1').style.width = state.p1.hp + '%';
        document.getElementById('hp-p2').style.width = state.p2.hp + '%';
        document.getElementById('wind-text').innerText = `WIND: ${Math.abs(state.wind * 100).toFixed(0)}`;
        document.getElementById('wind-arrow').style.transform = `rotate(${state.wind >= 0 ? 0 : 180}deg)`;
        
        const msg = document.getElementById('turn-msg');
        const myTurn = state.turn === (iAmP1 ? 1 : 2);
        msg.innerText = myTurn ? "YOUR TURN" : "ENEMY TURN";
        msg.style.color = myTurn ? 'var(--accent)' : 'white';
        msg.classList.toggle('show', true);
        if(state.gameOver) {
            msg.innerText = (state.p1.hp > 0 ? "PLAYER 1" : "PLAYER 2") + " WINS!";
            msg.style.color = 'white';
        }
    }
</script>
</body>
</html>
