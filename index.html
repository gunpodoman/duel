<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Core Artillery: Fully Loaded</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        /* ë””ìì¸ í…Œë§ˆ ì •ì˜ */
        :root {
            --sky-top: #87CEEB; --sky-bottom: #E0F6FF;
            --ground-top: #228B22; --ground-bottom: #0B3D0B;
            --p1-color: #0066FF; --p2-color: #FF3300;
            --ui-bg: rgba(0,0,0,0.6);
        }
        body { margin: 0; overflow: hidden; background: linear-gradient(to bottom, var(--sky-top), var(--sky-bottom)); font-family: 'Arial Black', sans-serif; touch-action: none; }
        
        /* ì´ˆëŒ€ ë° UI ì˜¤ë²„ë ˆì´ */
        #invite-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; color: white; text-align: center; }
        .btn-main { padding: 15px 40px; background: #FFD700; border: none; border-radius: 30px; font-weight: bold; font-size: 20px; cursor: pointer; color: #333; box-shadow: 0 5px 0 #DAA520; transition: 0.1s; }
        .btn-main:active { transform: translateY(5px); box-shadow: none; }

        /* ê²Œì„ í™”ë©´ UI */
        #game-container { width: 100vw; height: 100vh; position: relative; display: none; }
        canvas { display: block; }
        
        #ui-header { position: absolute; top: 0; left: 0; width: 100%; padding: 15px; box-sizing: border-box; display: flex; justify-content: space-between; pointer-events: none; }
        .player-panel { background: var(--ui-bg); padding: 10px 20px; border-radius: 20px; color: white; text-shadow: 1px 1px 2px black; backdrop-filter: blur(5px); }
        .hp-container { width: 150px; height: 18px; background: #333; border-radius: 10px; overflow: hidden; margin-top: 5px; border: 2px solid #555; }
        .hp-bar { height: 100%; transition: width 0.4s ease-out; }
        
        #turn-banner { position: absolute; top: 100px; width: 100%; text-align: center; font-size: 28px; color: white; text-shadow: 2px 2px 8px rgba(0,0,0,0.8); pointer-events: none; transition: 0.3s; opacity: 0; }
        #turn-banner.show { opacity: 1; top: 80px; }

        /* ì•„ì´í…œ ì»¨íŠ¸ë¡¤ UI */
        #item-controls { position: absolute; bottom: 30px; width: 100%; display: flex; justify-content: center; gap: 15px; pointer-events: none; }
        .item-btn { width: 60px; height: 60px; background: var(--ui-bg); border-radius: 15px; border: 3px solid #fff; color: white; font-size: 24px; display: flex; align-items: center; justify-content: center; cursor: pointer; pointer-events: auto; position: relative; transition: 0.2s; opacity: 0.5; }
        .item-btn.active { opacity: 1; transform: scale(1.1); border-color: #FFD700; background: rgba(255,215,0,0.3); }
        .item-btn.used { opacity: 0.3; cursor: not-allowed; border-color: #555; }
        .item-count { position: absolute; bottom: -5px; right: -5px; background: red; font-size: 12px; padding: 2px 6px; border-radius: 10px; border: 1px solid white; }
    </style>
</head>
<body>

<div id="invite-overlay">
    <h1 style="font-size: 40px; margin-bottom: 10px; text-shadow: 0 0 20px #FFD700;">ARTILLERY DUEL<br><span style="font-size:24px; color:#FFD700">Fully Loaded</span></h1>
    <p style="margin-bottom: 30px; color:#ccc;">ë“œë˜ê·¸ ì¡°ì¤€ & ì•„ì´í…œ ì „ëµ!</p>
    <button id="invite-btn" class="btn-main" onclick="copyInvite()" disabled>ë§í¬ ìƒì„± ì¤‘...</button>
</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-header">
        <div class="player-panel" style="border-left: 5px solid var(--p1-color)">
            P1 (Blue)
            <div class="hp-container"><div id="p1-hp" class="hp-bar" style="width:100%; background:var(--p1-color)"></div></div>
        </div>
        <div class="player-panel" style="border-right: 5px solid var(--p2-color); text-align: right;">
            P2 (Red)
            <div class="hp-container" style="justify-content: flex-end; display: flex;"><div id="p2-hp" class="hp-bar" style="width:100%; background:var(--p2-color)"></div></div>
        </div>
    </div>
    <div id="turn-banner">ê²Œì„ ì‹œì‘ ëŒ€ê¸° ì¤‘...</div>
    
    <div id="item-controls" style="display:none;">
        <div class="item-btn" id="btn-double" onclick="useItem('double')">ğŸ”¥<span class="item-count" id="cnt-double">1</span></div>
        <div class="item-btn" id="btn-big" onclick="useItem('big')">ğŸ’£<span class="item-count" id="cnt-big">1</span></div>
        <div class="item-btn" id="btn-heal" onclick="useItem('heal')">â¤ï¸<span class="item-count" id="cnt-heal">1</span></div>
    </div>
</div>

<script>
    // === ì„¤ì • ë° ìƒìˆ˜ ===
    const GRAVITY = 0.25;
    const MAX_POWER = 30;
    const TANK_SIZE = 30;
    let canvas, ctx, width, height;
    let myId, conn, isHost = false, iAmP1 = false;
    let animationId;
    let explosions = []; // í­ë°œ ì´í™íŠ¸ ê´€ë¦¬

    // === ê²Œì„ ìƒíƒœ ===
    let gameState = {
        terrain: [],
        p1: { x: 100, y: 0, hp: 100, color: '#0066FF', items: { double: 1, big: 1, heal: 1 } },
        p2: { x: 0, y: 0, hp: 100, color: '#FF3300', items: { double: 1, big: 1, heal: 1 } },
        turn: 1,
        projectiles: [], // ë‹¤ì¤‘ í¬íƒ„ ì§€ì›
        activeItem: null, // í˜„ì¬ í„´ì— í™œì„±í™”ëœ ì•„ì´í…œ
        gameOver: false
    };

    // === 1. ë„¤íŠ¸ì›Œí¬ ë° ì´ˆê¸°í™” ===
    const peer = new Peer(null, { config: {'iceServers': [{ url: 'stun:stun.l.google.com:19302' }]} });
    peer.on('open', id => {
        myId = id;
        document.getElementById('invite-btn').disabled = false;
        document.getElementById('invite-btn').innerText = "ë§í¬ ë³µì‚¬ & ì‹œì‘";
        if(window.location.hash) connectTo(window.location.hash.substring(1));
    });
    peer.on('connection', c => { conn = c; isHost = true; iAmP1 = true; setupConn(); });

    function copyInvite() {
        navigator.clipboard.writeText(`${window.location.origin}${window.location.pathname}#${myId}`)
        .then(() => alert("ë§í¬ ë³µì‚¬ ì™„ë£Œ! ìƒëŒ€ê°€ ì ‘ì†í•˜ë©´ ê²Œì„ì´ ì‹œì‘ë©ë‹ˆë‹¤."));
    }
    function connectTo(tid) { conn = peer.connect(tid); isHost = false; iAmP1 = false; setupConn(); }

    function setupConn() {
        conn.on('open', () => {
            document.getElementById('invite-overlay').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            initCanvas(); setupInput();
            if(isHost) initGameHost();
            gameLoop();
        });
        conn.on('data', data => {
            if(isHost && data.type === 'FIRE') { handleFireRequest(data.angle, data.power, data.item); }
            else if(isHost && data.type === 'HEAL') { applyHeal(2); }
            else if(!isHost && data.type === 'SYNC') { 
                gameState = data.state; updateUI(); 
                if(data.explosion) createExplosion(data.explosion.x, data.explosion.y, data.explosion.isBig);
            }
        });
    }

    // === 2. ê²Œì„ ë¡œì§ (í˜¸ìŠ¤íŠ¸ ì¤‘ì‹¬) ===
    function initCanvas() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        resize(); window.addEventListener('resize', resize);
    }
    function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }

    function initGameHost() {
        gameState.terrain = [];
        let h = height * 0.7;
        for(let x=0; x<=width; x+=20) {
            h += (Math.random() - 0.5) * 30; // ëœë¤ ì§€í˜•
            h = Math.max(height*0.4, Math.min(height*0.9, h)); // ë†’ì´ ì œí•œ
            gameState.terrain.push({x: x, y: h});
        }
        // í‰íƒ„í™” ì‘ì—…
        for(let i=1; i<gameState.terrain.length-1; i++) {
            gameState.terrain[i].y = (gameState.terrain[i-1].y + gameState.terrain[i].y + gameState.terrain[i+1].y) / 3;
        }
        gameState.p1.y = getTerrainHeight(gameState.p1.x);
        gameState.p2.x = width - 100; gameState.p2.y = getTerrainHeight(gameState.p2.x);
        sync();
    }

    function getTerrainHeight(x) {
        if(x < 0 || x > width) return height;
        for(let i=0; i<gameState.terrain.length-1; i++) {
            if(x >= gameState.terrain[i].x && x <= gameState.terrain[i+1].x) {
                const t = (x - gameState.terrain[i].x) / (gameState.terrain[i+1].x - gameState.terrain[i].x);
                return gameState.terrain[i].y * (1-t) + gameState.terrain[i+1].y * t; // ì„ í˜• ë³´ê°„
            }
        }
        return height;
    }

    function handleFireRequest(angle, power, itemType) {
        if(gameState.projectiles.length > 0 || gameState.gameOver) return;
        
        const shooterIdx = gameState.turn === 1 ? 'p1' : 'p2';
        const shooter = gameState[shooterIdx];

        // ì•„ì´í…œ ì‚¬ìš© ì²˜ë¦¬
        let isBig = false;
        let shotCount = 1;
        if(itemType === 'big' && shooter.items.big > 0) { isBig = true; shooter.items.big--; }
        else if(itemType === 'double' && shooter.items.double > 0) { shotCount = 2; shooter.items.double--; }
        
        gameState.activeItem = null; // ì‚¬ìš© í›„ ì´ˆê¸°í™”

        for(let i=0; i<shotCount; i++) {
            setTimeout(() => {
                 gameState.projectiles.push({
                    x: shooter.x, y: shooter.y - TANK_SIZE,
                    vx: Math.cos(angle) * power, vy: Math.sin(angle) * power,
                    radius: isBig ? 8 : 5, isBig: isBig, rotation: 0
                });
                if(isHost) sync();
            }, i * 300); // ë”ë¸”ìƒ· ë”œë ˆì´
        }
    }

    function applyHeal(playerNum) {
        if(!isHost || gameState.gameOver) return;
        const pStr = playerNum === 1 ? 'p1' : 'p2';
        if(gameState[pStr].items.heal > 0) {
            gameState[pStr].hp = Math.min(100, gameState[pStr].hp + 30);
            gameState[pStr].items.heal--;
            sync();
        }
    }

    function updatePhysics() {
        if(!isHost || gameState.gameOver) return;
        
        gameState.projectiles.forEach((p, idx) => {
            p.vy += GRAVITY; p.x += p.vx; p.y += p.vy;
            p.rotation += 0.1; // í¬íƒ„ íšŒì „

            // ì¶©ëŒ ì²´í¬
            const terrainH = getTerrainHeight(p.x);
            if(p.y > terrainH || p.x < -100 || p.x > width + 100) {
                createExplosion(p.x, p.y, p.isBig);
                checkHit(p.x, p.y, p.isBig);
                gameState.projectiles.splice(idx, 1);
                sync({x:p.x, y:p.y, isBig:p.isBig}); // í­ë°œ ì •ë³´ ì „ì†¡

                // ëª¨ë“  í¬íƒ„ì´ í„°ì¡Œìœ¼ë©´ í„´ ë„˜ê¸°ê¸°
                if(gameState.projectiles.length === 0) {
                    setTimeout(() => {
                         if(!gameState.gameOver) {
                            gameState.turn = gameState.turn === 1 ? 2 : 1;
                            sync();
                         }
                    }, 1000);
                }
            }
        });
    }

    function checkHit(x, y, isBig) {
        const target = gameState.turn === 1 ? gameState.p2 : gameState.p1;
        const dist = Math.sqrt((x-target.x)**2 + (y-target.y)**2);
        const hitRadius = TANK_SIZE + (isBig ? 30 : 15);
        const damage = isBig ? 50 : 30;

        if(dist < hitRadius) {
            target.hp = Math.max(0, target.hp - damage);
            if(target.hp === 0) {
                gameState.gameOver = true;
                setTimeout(() => alert(`${gameState.turn === 1 ? 'P1' : 'P2'} Wins!`), 500);
            }
        }
    }

    function sync(explosionData = null) { if(isHost && conn) conn.send({type: 'SYNC', state: gameState, explosion: explosionData}); updateUI(); }

    // === 3. ì…ë ¥ ë° ë Œë”ë§ ===
    let aiming = null;
    function setupInput() {
        canvas.addEventListener('pointerdown', e => {
            if(gameState.gameOver || gameState.turn !== (iAmP1 ? 1 : 2) || gameState.projectiles.length > 0) return;
            aiming = { startX: e.clientX, startY: e.clientY, currentX: e.clientX, currentY: e.clientY };
        });
        canvas.addEventListener('pointermove', e => { if(aiming) { aiming.currentX = e.clientX; aiming.currentY = e.clientY; }});
        canvas.addEventListener('pointerup', e => {
            if(!aiming) return;
            const dx = aiming.startX - aiming.currentX, dy = aiming.startY - aiming.currentY;
            const power = Math.min(Math.sqrt(dx*dx + dy*dy) / 8, MAX_POWER);
            const angle = Math.atan2(dy, dx);
            aiming = null;
            if(power > 3) {
                const item = gameState.activeItem;
                if(isHost) handleFireRequest(angle, power, item);
                else conn.send({type: 'FIRE', angle, power, item});
            }
        });
    }

    function useItem(type) {
        const myP = iAmP1 ? gameState.p1 : gameState.p2;
        if(gameState.turn !== (iAmP1 ? 1 : 2) || myP.items[type] === 0 || gameState.projectiles.length > 0) return;

        if(type === 'heal') {
            if(isHost) applyHeal(1); else conn.send({type:'HEAL'});
        } else {
            // ê³µê²© ì•„ì´í…œì€ í† ê¸€ ë°©ì‹
            gameState.activeItem = (gameState.activeItem === type) ? null : type;
            updateUI();
        }
    }

    function createExplosion(x, y, isBig) {
        explosions.push({x, y, radius: 0, maxRadius: isBig ? 60 : 40, alpha: 1});
    }

    function gameLoop() {
        updatePhysics();
        draw();
        animationId = requestAnimationFrame(gameLoop);
    }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        
        // ì§€í˜• ê·¸ë¦¬ê¸° (í…ìŠ¤ì²˜ ëŠë‚Œ)
        const gradient = ctx.createLinearGradient(0, height*0.5, 0, height);
        gradient.addColorStop(0, 'var(--ground-top)'); gradient.addColorStop(1, 'var(--ground-bottom)');
        ctx.fillStyle = gradient;
        ctx.beginPath(); ctx.moveTo(0, height);
        gameState.terrain.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(width, height); ctx.fill();
        // ì§€í˜• í…Œë‘ë¦¬
        ctx.strokeStyle = '#1a472a'; ctx.lineWidth = 3; ctx.beginPath();
        gameState.terrain.forEach((p,i) => i===0 ? ctx.moveTo(p.x,p.y) : ctx.lineTo(p.x,p.y)); ctx.stroke();

        drawTank(gameState.p1); drawTank(gameState.p2);

        // í¬íƒ„ ê·¸ë¦¬ê¸°
        gameState.projectiles.forEach(p => {
            ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.rotation);
            ctx.fillStyle = p.isBig ? '#FF4500' : '#333';
            ctx.beginPath(); 
            if(p.isBig) { ctx.arc(0, 0, p.radius, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='yellow'; ctx.lineWidth=2; ctx.stroke(); }
            else { ctx.fillRect(-p.radius, -p.radius/2, p.radius*2, p.radius); } // ê°„ë‹¨í•œ ë¯¸ì‚¬ì¼ ëª¨ì–‘
            ctx.restore();
        });

        // ì¡°ì¤€ì„ 
        if(aiming && gameState.turn === (iAmP1 ? 1 : 2)) {
            const me = iAmP1 ? gameState.p1 : gameState.p2;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)'; ctx.lineWidth = 4; ctx.setLineDash([8, 6]);
            ctx.beginPath(); ctx.moveTo(me.x, me.y - TANK_SIZE*0.8);
            ctx.lineTo(me.x + (aiming.startX - aiming.currentX), me.y - TANK_SIZE*0.8 + (aiming.startY - aiming.currentY));
            ctx.stroke(); ctx.setLineDash([]);
        }

        // í­ë°œ ì´í™íŠ¸
        explosions.forEach((e, i) => {
            ctx.fillStyle = `rgba(255, 69, 0, ${e.alpha})`;
            ctx.beginPath(); ctx.arc(e.x, e.y, e.radius, 0, Math.PI*2); ctx.fill();
            e.radius += 2; e.alpha -= 0.02;
            if(e.alpha <= 0) explosions.splice(i, 1);
        });
    }

    function drawTank(p) {
        ctx.save(); ctx.translate(p.x, p.y);
        ctx.fillStyle = p.color; ctx.strokeStyle = '#222'; ctx.lineWidth = 2;
        // ëª¸ì²´
        ctx.beginPath(); ctx.roundRect(-20, -15, 40, 20, 5); ctx.fill(); ctx.stroke();
        // ê¶¤ë„
        ctx.fillStyle = '#333'; ctx.beginPath(); ctx.roundRect(-22, 0, 44, 10, 3); ctx.fill();
        // í¬íƒ‘
        ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(0, -15, 12, Math.PI, 0); ctx.fill(); ctx.stroke();
        // í¬ì‹  (ë°©í–¥ì€ ê³ ì •)
        ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(0, -20); ctx.lineTo(p === gameState.p1 ? 20 : -20, -25); ctx.stroke();
        ctx.restore();
    }

    function updateUI() {
        document.getElementById('p1-hp').style.width = gameState.p1.hp + '%';
        document.getElementById('p2-hp').style.width = gameState.p2.hp + '%';
        
        const turnBanner = document.getElementById('turn-banner');
        const myTurn = gameState.turn === (iAmP1 ? 1 : 2);
        turnBanner.innerText = myTurn ? "ë‹¹ì‹ ì˜ ì°¨ë¡€!" : (gameState.turn === 1 ? "Blue ì°¨ë¡€" : "Red ì°¨ë¡€");
        turnBanner.classList.add('show');
        turnBanner.style.color = myTurn ? '#FFD700' : 'white';

        document.getElementById('item-controls').style.display = myTurn ? 'flex' : 'none';
        if(myTurn) {
            const myItems = iAmP1 ? gameState.p1.items : gameState.p2.items;
            updateItemBtn('double', myItems.double, 'ğŸ”¥');
            updateItemBtn('big', myItems.big, 'ğŸ’£');
            updateItemBtn('heal', myItems.heal, 'â¤ï¸');
        }
    }

    function updateItemBtn(type, count, icon) {
        const btn = document.getElementById(`btn-${type}`);
        document.getElementById(`cnt-${type}`).innerText = count;
        if(count === 0) { btn.classList.add('used'); btn.classList.remove('active'); }
        else { btn.classList.remove('used'); btn.classList.toggle('active', gameState.activeItem === type); }
    }
</script>
</body>
</html>
