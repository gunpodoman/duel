<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Artillery Duel: Ultimate Sync</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root { --p1: #3b82f6; --p2: #ef4444; --accent: #fbbf24; --bg: #0f172a; }
        body { margin: 0; overflow: hidden; background: var(--bg); font-family: system-ui, -apple-system, sans-serif; touch-action: none; color: white; }
        
        /* 로딩/초대 UI */
        #overlay { position: fixed; inset: 0; background: radial-gradient(circle at center, #1e293b 0%, #020617 100%); z-index: 100; display: flex; align-items: center; justify-content: center; }
        .setup-card { background: rgba(255,255,255,0.03); padding: 40px; border-radius: 32px; border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(20px); text-align: center; width: 320px; }
        .btn { width: 100%; padding: 16px; background: var(--accent); border: none; border-radius: 16px; font-weight: 800; font-size: 18px; cursor: pointer; color: #000; transition: 0.2s; box-shadow: 0 0 20px rgba(251,191,36,0.3); }
        .btn:disabled { background: #334155; color: #94a3b8; box-shadow: none; cursor: wait; }

        /* 게임 메인 UI */
        #game-container { display: none; width: 100vw; height: 100vh; position: relative; }
        #ui-layer { position: absolute; inset: 0; pointer-events: none; padding: 20px; }
        .status-container { display: flex; justify-content: space-between; align-items: flex-start; }
        .p-panel { background: rgba(0,0,0,0.4); padding: 12px 20px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1); width: 140px; }
        .hp-bar { width: 100%; height: 8px; background: #1e293b; border-radius: 4px; margin-top: 8px; overflow: hidden; }
        .hp-inner { height: 100%; transition: width 0.5s ease-out; }
        
        #wind-display { background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 40px; border: 1px solid var(--accent); font-weight: 900; }
        #message { position: absolute; top: 120px; width: 100%; text-align: center; font-size: 36px; font-weight: 900; text-shadow: 0 0 20px rgba(0,0,0,0.5); transform: translateY(20px); opacity: 0; transition: 0.4s; }
        #message.show { transform: translateY(0); opacity: 1; }
    </style>
</head>
<body>

<div id="overlay">
    <div class="setup-card">
        <h1 style="margin: 0 0 8px 0; font-size: 28px;">CANNON DUEL</h1>
        <p style="color: #94a3b8; margin-bottom: 32px; font-size: 14px;">상대를 조준하고 포격하세요!</p>
        <button id="invite-btn" class="btn" onclick="copyLink()" disabled>연결 서버 접속 중...</button>
        <p id="conn-status" style="margin-top: 16px; font-size: 12px; color: var(--accent);"></p>
    </div>
</div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div class="status-container">
            <div class="p-panel" style="border-left: 4px solid var(--p1)">
                <div style="font-size: 12px; opacity: 0.7;">PLAYER 1</div>
                <div class="hp-bar"><div id="hp-1" class="hp-inner" style="width: 100%; background: var(--p1);"></div></div>
            </div>
            <div id="wind-display">WIND: 0.00 →</div>
            <div class="p-panel" style="border-right: 4px solid var(--p2); text-align: right;">
                <div style="font-size: 12px; opacity: 0.7;">PLAYER 2</div>
                <div class="hp-bar"><div id="hp-2" class="hp-inner" style="width: 100%; background: var(--p2);"></div></div>
            </div>
        </div>
        <div id="message">READY</div>
    </div>
</div>

<script>
    // --- 설정 및 상수 ---
    const GRAVITY = 0.25;
    const TANK_SIZE = 35;
    let canvas, ctx, w, h;
    let myId, conn, isHost = false, myNum = 0;
    let explosions = [];

    // --- 게임 상태 ---
    let gameState = {
        terrain: [],
        p1: { x: 100, y: 0, hp: 100, angle: -0.5 },
        p2: { x: 0, y: 0, hp: 100, angle: 3.6 },
        turn: 1,
        wind: 0,
        ball: null, // 포탄 물리 객체
        gameOver: false
    };

    // --- 1. 안정적인 PeerJS 연결 시스템 ---
    const peer = new Peer(null, {
        config: {'iceServers': [{ url: 'stun:stun.l.google.com:19302' }, { url: 'stun:stun1.l.google.com:19302' }]},
        debug: 1
    });

    peer.on('open', id => {
        myId = id;
        document.getElementById('invite-btn').disabled = false;
        document.getElementById('invite-btn').innerText = "초대 링크 복사";
        if(window.location.hash) connectToHost(window.location.hash.substring(1));
    });

    // 호스트 입장에서 게스트를 맞이함
    peer.on('connection', c => {
        if(conn) return; // 이미 연결된 경우 차단
        conn = c; isHost = true; myNum = 1;
        setupConn();
    });

    function connectToHost(targetId) {
        document.getElementById('conn-status').innerText = "호스트에 연결 시도 중...";
        conn = peer.connect(targetId, { reliable: true });
        isHost = false; myNum = 2;
        setupConn();
    }

    function setupConn() {
        conn.on('open', () => {
            document.getElementById('overlay').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            initCanvas();
            if(isHost) {
                generateTerrain();
                sendSync();
            }
            requestAnimationFrame(gameLoop);
        });

        conn.on('data', data => {
            if(data.type === 'SYNC') {
                gameState.terrain = data.terrain;
                gameState.p1 = data.p1;
                gameState.p2 = data.p2;
                gameState.wind = data.wind;
                gameState.turn = data.turn;
                updateUI();
            }
            if(data.type === 'FIRE_EVENT') {
                // 핵심: 각자 화면에서 물리 엔진 가동
                gameState.ball = {
                    x: data.x, y: data.y,
                    vx: data.vx, vy: data.vy,
                    wind: data.wind // 발사 시점의 바람 고정
                };
            }
        });

        conn.on('close', () => { alert("상대방과 연결이 끊어졌습니다."); location.reload(); });
        conn.on('error', () => { alert("연결 오류가 발생했습니다."); location.reload(); });
    }

    function copyLink() {
        const link = `${window.location.origin}${window.location.pathname}#${myId}`;
        navigator.clipboard.writeText(link).then(() => {
            document.getElementById('conn-status').innerText = "링크 복사 완료! 상대방이 들어오면 시작됩니다.";
        });
    }

    // --- 2. 물리 및 게임 로직 ---
    function initCanvas() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        resize();
        window.addEventListener('resize', resize);
        setupInput();
    }

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
    }

    function generateTerrain() {
        gameState.terrain = [];
        let curH = h * 0.7;
        for(let x = 0; x <= w + 100; x += 50) {
            curH += (Math.random() - 0.5) * 120;
            curH = Math.max(h * 0.4, Math.min(h * 0.8, curH));
            gameState.terrain.push({x, y: curH});
        }
        gameState.p1.x = w * 0.15; gameState.p1.y = getTerrainY(gameState.p1.x);
        gameState.p2.x = w * 0.85; gameState.p2.y = getTerrainY(gameState.p2.x);
        gameState.wind = (Math.random() - 0.5) * 0.4;
    }

    function getTerrainY(x) {
        for(let i=0; i<gameState.terrain.length-1; i++) {
            if(x >= gameState.terrain[i].x && x <= gameState.terrain[i+1].x) {
                let r = (x - gameState.terrain[i].x) / (gameState.terrain[i+1].x - gameState.terrain[i].x);
                return gameState.terrain[i].y * (1-r) + gameState.terrain[i+1].y * r;
            }
        }
        return h;
    }

    function sendSync() {
        if(!isHost) return;
        conn.send({
            type: 'SYNC',
            terrain: gameState.terrain,
            p1: gameState.p1, p2: gameState.p2,
            wind: gameState.wind, turn: gameState.turn
        });
        updateUI();
    }

    // --- 3. 렌더링 및 애니메이션 ---
    function gameLoop() {
        updatePhysics();
        draw();
        requestAnimationFrame(gameLoop);
    }

    function updatePhysics() {
        if(!gameState.ball) return;

        const b = gameState.ball;
        b.vx += b.wind; // 저장된 바람 세기 적용
        b.vy += GRAVITY;
        b.x += b.vx;
        b.y += b.vy;

        const groundY = getTerrainY(b.x);
        if(b.y > groundY || b.x < 0 || b.x > w) {
            // 폭발 이펙트 (양쪽 동일 생성)
            createExplosion(b.x, b.y, gameState.turn === 1 ? '#3b82f6' : '#ef4444');
            
            if(isHost) {
                checkDamage(b.x, b.y);
                gameState.ball = null;
                gameState.turn = gameState.turn === 1 ? 2 : 1;
                gameState.wind = (Math.random() - 0.5) * 0.4;
                sendSync();
            } else {
                gameState.ball = null; // 게스트도 물리 정지 (호스트의 SYNC 대기)
            }
        }
    }

    function checkDamage(bx, by) {
        const target = gameState.turn === 1 ? gameState.p2 : gameState.p1;
        const dist = Math.sqrt((bx - target.x)**2 + (by - target.y)**2);
        if(dist < TANK_SIZE + 20) {
            target.hp = Math.max(0, target.hp - 34);
            if(target.hp <= 0) gameState.gameOver = true;
        }
    }

    function draw() {
        ctx.clearRect(0, 0, w, h);
        
        // 하늘
        let grad = ctx.createLinearGradient(0,0,0,h);
        grad.addColorStop(0, '#020617'); grad.addColorStop(1, '#1e293b');
        ctx.fillStyle = grad; ctx.fillRect(0,0,w,h);

        // 지형
        if(gameState.terrain.length > 0) {
            ctx.beginPath();
            ctx.moveTo(0, h);
            gameState.terrain.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(w, h);
            ctx.fillStyle = '#0f172a'; ctx.fill();
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 3; ctx.stroke();
        }

        // 탱크
        drawTank(gameState.p1, 1);
        drawTank(gameState.p2, 2);

        // 포탄
        if(gameState.ball) {
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 15; ctx.shadowColor = '#fff';
            ctx.beginPath(); ctx.arc(gameState.ball.x, gameState.ball.y, 6, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;
        }

        // 궤적 가이드
        if(aiming.active && gameState.turn === myNum && !gameState.ball) {
            drawTrajectory();
        }

        // 폭발 파티클
        explosions.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.a -= 0.02;
            ctx.fillStyle = p.c.replace(')', `, ${p.a})`).replace('rgb', 'rgba');
            ctx.fillRect(p.x, p.y, p.s, p.s);
            if(p.a <= 0) explosions.splice(i, 1);
        });
    }

    function drawTank(p, num) {
        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.fillStyle = num === 1 ? '#3b82f6' : '#ef4444';
        // 몸체
        ctx.beginPath(); ctx.roundRect(-22, -12, 44, 18, 6); ctx.fill();
        // 포탑
        ctx.beginPath(); ctx.arc(0, -12, 12, Math.PI, 0); ctx.fill();
        // 포신
        ctx.strokeStyle = num === 1 ? '#3b82f6' : '#ef4444'; ctx.lineWidth = 8; ctx.lineCap = 'round';
        ctx.beginPath(); ctx.moveTo(0, -15);
        ctx.lineTo(Math.cos(p.angle) * 30, Math.sin(p.angle) * 30 - 15);
        ctx.stroke();
        ctx.restore();
    }

    function drawTrajectory() {
        const p = myNum === 1 ? gameState.p1 : gameState.p2;
        const dx = aiming.sx - aiming.cx, dy = aiming.sy - aiming.cy;
        const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 25);
        const angle = Math.atan2(dy, dx);
        
        ctx.beginPath(); ctx.setLineDash([6, 6]); ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        let tx = p.x, ty = p.y - 15, tvx = Math.cos(angle) * power, tvy = Math.sin(angle) * power;
        for(let i=0; i<40; i++) {
            ctx.lineTo(tx, ty);
            tvx += gameState.wind; tvy += GRAVITY; tx += tvx; ty += tvy;
        }
        ctx.stroke(); ctx.setLineDash([]);
    }

    function createExplosion(x, y, color) {
        const rgb = color === '#3b82f6' ? 'rgb(59, 130, 246)' : 'rgb(239, 68, 68)';
        for(let i=0; i<30; i++) {
            explosions.push({
                x, y, vx: (Math.random()-0.5)*12, vy: (Math.random()-0.5)*12,
                s: Math.random()*6+2, a: 1, c: rgb
            });
        }
    }

    // --- 4. 조작 시스템 ---
    let aiming = { active: false, sx: 0, sy: 0, cx: 0, cy: 0 };
    function setupInput() {
        canvas.addEventListener('pointerdown', e => {
            if(gameState.turn !== myNum || gameState.ball || gameState.gameOver) return;
            aiming.active = true;
            aiming.sx = aiming.cx = e.clientX; aiming.sy = aiming.cy = e.clientY;
        });
        window.addEventListener('pointermove', e => {
            if(!aiming.active) return;
            aiming.cx = e.clientX; aiming.cy = e.clientY;
            const p = myNum === 1 ? gameState.p1 : gameState.p2;
            p.angle = Math.atan2(aiming.sy - aiming.cy, aiming.sx - aiming.cx);
        });
        window.addEventListener('pointerup', () => {
            if(!aiming.active) return;
            aiming.active = false;
            const dx = aiming.sx - aiming.cx, dy = aiming.sy - aiming.cy;
            const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 25);
            const angle = Math.atan2(dy, dx);
            if(power > 3) {
                const fireData = {
                    type: 'FIRE_EVENT',
                    x: (myNum === 1 ? gameState.p1.x : gameState.p2.x),
                    y: (myNum === 1 ? gameState.p1.y : gameState.p2.y) - 15,
                    vx: Math.cos(angle) * power,
                    vy: Math.sin(angle) * power,
                    wind: gameState.wind
                };
                conn.send(fireData); // 상대에게 발사 정보 전송
                gameState.ball = { x: fireData.x, y: fireData.y, vx: fireData.vx, vy: fireData.vy, wind: fireData.wind }; // 내 화면 시뮬레이션
            }
        });
    }

    function updateUI() {
        document.getElementById('hp-1').style.width = gameState.p1.hp + '%';
        document.getElementById('hp-2').style.width = gameState.p2.hp + '%';
        const wind = gameState.wind * 100;
        document.getElementById('wind-display').innerText = `WIND: ${Math.abs(wind).toFixed(1)} ${wind >= 0 ? '→' : '←'}`;
        
        const msg = document.getElementById('message');
        const myTurn = gameState.turn === myNum;
        msg.innerText = myTurn ? "YOUR TURN" : "ENEMY TURN";
        msg.style.color = myTurn ? 'var(--accent)' : '#fff';
        msg.classList.toggle('show', true);
        if(gameState.gameOver) msg.innerText = (gameState.p1.hp > 0 ? "BLUE" : "RED") + " WINS!";
    }
</script>
</body>
</html>
