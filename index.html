<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cannon Duel Online</title>
    <!-- PeerJS Library for P2P Networking -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --p1-color: #3b82f6;
            --p2-color: #ef4444;
            --bg-color: #0f172a;
            --accent: #f59e0b;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Pretendard', system-ui, sans-serif;
            color: white;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        canvas {
            display: block;
        }

        /* --- UI Panels --- */
        #lobby {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, #1e293b 0%, #020617 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            padding: 20px;
            text-align: center;
        }

        .card {
            background: rgba(30, 41, 59, 0.7);
            padding: 40px;
            border-radius: 24px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            max-width: 400px;
            width: 100%;
        }

        h1 { margin: 0 0 10px; font-size: 2.5rem; letter-spacing: -1px; }
        p { color: #94a3b8; margin-bottom: 30px; }

        .btn {
            background: var(--accent);
            color: black;
            border: none;
            padding: 16px 32px;
            border-radius: 12px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            width: 100%;
        }

        .btn:hover { background: #fbbf24; transform: translateY(-2px); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { background: #475569; cursor: not-allowed; transform: none; }

        #status-badge {
            margin-bottom: 20px;
            padding: 6px 16px;
            border-radius: 99px;
            font-size: 0.8rem;
            font-weight: bold;
            display: inline-block;
        }

        .status-wait { background: #334155; color: #cbd5e1; }
        .status-ready { background: #065f46; color: #34d399; }

        /* --- In-Game HUD --- */
        #hud {
            position: absolute;
            top: 20px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 40px;
            pointer-events: none;
            display: none;
        }

        .player-info {
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 15px;
            width: 200px;
            backdrop-filter: blur(5px);
            border-bottom: 4px solid transparent;
        }

        #p1-info { border-color: var(--p1-color); }
        #p2-info { border-color: var(--p2-color); }

        .hp-container {
            width: 100%;
            height: 10px;
            background: #334155;
            border-radius: 5px;
            margin-top: 8px;
            overflow: hidden;
        }

        .hp-bar {
            height: 100%;
            width: 100%;
            transition: width 0.3s ease-out;
        }

        #wind-indicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.4);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 900;
            color: var(--accent);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }

        #turn-msg {
            position: absolute;
            top: 120px;
            width: 100%;
            text-align: center;
            font-size: 3rem;
            font-weight: 900;
            text-transform: uppercase;
            pointer-events: none;
            text-shadow: 0 4px 10px rgba(0,0,0,0.5);
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }

        #turn-msg.show { opacity: 1; transform: translateY(-10px); }
    </style>
</head>
<body>

<div id="lobby">
    <div class="card">
        <h1>CANNON DUEL</h1>
        <p>친구와 함께하는 실시간 포격전</p>
        <div id="status-badge" class="status-wait">서버 연결 중...</div>
        <button id="invite-btn" class="btn" onclick="copyInviteLink()" disabled>기다려 주세요</button>
        <div id="connection-info" style="margin-top: 20px; font-size: 0.85rem; color: #64748b;"></div>
    </div>
</div>

<div id="game-container">
    <div id="hud">
        <div id="p1-info" class="player-info">
            <div style="font-size: 0.8rem; font-weight: bold; color: var(--p1-color);">PLAYER 1 (BLUE)</div>
            <div class="hp-container"><div id="hp1" class="hp-bar" style="background: var(--p1-color);"></div></div>
        </div>
        <div id="wind-indicator">WIND: 0.00</div>
        <div id="p2-info" class="player-info" style="text-align: right;">
            <div style="font-size: 0.8rem; font-weight: bold; color: var(--p2-color);">PLAYER 2 (RED)</div>
            <div class="hp-container"><div id="hp2" class="hp-bar" style="background: var(--p2-color);"></div></div>
        </div>
    </div>
    <div id="turn-msg">YOUR TURN</div>
    <canvas id="gameCanvas"></canvas>
</div>

<script>
    // --- 설정 및 상수 ---
    const GRAVITY = 0.2;
    const MAX_HP = 100;
    const TANK_WIDTH = 40;
    const TANK_HEIGHT = 20;
    const EXPLOSION_RADIUS = 60;

    let canvas, ctx, w, h;
    let myId, conn;
    let isHost = false;
    let playerNum = 0; // 1 or 2
    let terrain = [];
    let particles = [];
    
    // 게임 상태
    let state = {
        p1: { x: 100, y: 0, hp: MAX_HP, angle: -Math.PI / 4 },
        p2: { x: 700, y: 0, hp: MAX_HP, angle: -Math.PI * 0.75 },
        wind: 0,
        turn: 1,
        ball: null,
        gameOver: false
    };

    // 마우스/터치 입력
    let input = { active: false, startX: 0, startY: 0, currX: 0, currY: 0 };

    // --- 네트워킹 로직 ---
    const peer = new Peer();

    peer.on('open', (id) => {
        myId = id;
        const btn = document.getElementById('invite-btn');
        btn.disabled = false;
        btn.innerText = "초대 링크 복사";
        document.getElementById('status-badge').innerText = "온라인";
        document.getElementById('status-badge').className = "status-ready";
        
        // URL에 해시가 있으면 게스트로 접속
        if (window.location.hash) {
            connectToHost(window.location.hash.substring(1));
        }
    });

    peer.on('connection', (connection) => {
        if (conn) return; // 이미 연결된 경우 차단
        conn = connection;
        isHost = true;
        playerNum = 1;
        setupConnection();
    });

    function connectToHost(hostId) {
        conn = peer.connect(hostId);
        isHost = false;
        playerNum = 2;
        setupConnection();
    }

    function setupConnection() {
        conn.on('open', () => {
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            initCanvas();
            
            if (isHost) {
                generateTerrain();
                state.p1.x = w * 0.15;
                state.p2.x = w * 0.85;
                state.p1.y = getTerrainHeight(state.p1.x);
                state.p2.y = getTerrainHeight(state.p2.x);
                state.wind = (Math.random() - 0.5) * 0.3;
                setTimeout(sendSync, 500);
            } else {
                conn.send({ type: 'REQUEST_INIT' });
            }
            
            requestAnimationFrame(gameLoop);
            showTurnMessage();
        });

        conn.on('data', (data) => {
            if (data.type === 'SYNC') {
                state = data.state;
                updateUI();
            } else if (data.type === 'REQUEST_INIT' && isHost) {
                sendSync();
            } else if (data.type === 'FIRE') {
                state.ball = data.ball;
                state.ball.isSafe = true; // 발사 초기 자폭 방지
            }
        });
    }

    function sendSync() {
        if (conn && conn.open && isHost) {
            conn.send({ type: 'SYNC', state: state });
        }
        updateUI();
    }

    function copyInviteLink() {
        const link = window.location.origin + window.location.pathname + '#' + myId;
        navigator.clipboard.writeText(link).then(() => {
            document.getElementById('connection-info').innerText = "링크가 복사되었습니다! 친구에게 공유하세요.";
        });
    }

    // --- 게임 로직 ---
    function initCanvas() {
        canvas = document.getElementById('gameCanvas');
        ctx = canvas.getContext('2d');
        resize();
        window.addEventListener('resize', resize);
        
        canvas.addEventListener('mousedown', startInput);
        canvas.addEventListener('mousemove', moveInput);
        canvas.addEventListener('mouseup', endInput);
        
        canvas.addEventListener('touchstart', (e) => startInput(e.touches[0]));
        canvas.addEventListener('touchmove', (e) => moveInput(e.touches[0]));
        canvas.addEventListener('touchend', () => endInput());
    }

    function resize() {
        w = canvas.width = window.innerWidth;
        h = canvas.height = window.innerHeight;
        if (isHost && terrain.length > 0) {
            // 지형 재설정 로직 (생략 가능하지만 호스트 기준 통일 필요)
        }
    }

    function generateTerrain() {
        terrain = [];
        let currentHeight = h * 0.6;
        for (let x = 0; x <= w + 100; x += 40) {
            currentHeight += (Math.random() - 0.5) * 100;
            currentHeight = Math.max(h * 0.4, Math.min(h * 0.8, currentHeight));
            terrain.push({ x, y: currentHeight });
        }
        state.terrain = terrain;
    }

    function getTerrainHeight(x) {
        const t = state.terrain;
        for (let i = 0; i < t.length - 1; i++) {
            if (x >= t[i].x && x <= t[i+1].x) {
                const ratio = (x - t[i].x) / (t[i+1].x - t[i].x);
                return t[i].y + (t[i+1].y - t[i].y) * ratio;
            }
        }
        return h;
    }

    function startInput(e) {
        if (state.turn !== playerNum || state.ball || state.gameOver) return;
        input.active = true;
        input.startX = input.currX = e.clientX;
        input.startY = input.currY = e.clientY;
    }

    function moveInput(e) {
        if (!input.active) return;
        input.currX = e.clientX;
        input.currY = e.clientY;
        
        const dx = input.startX - input.currX;
        const dy = input.startY - input.currY;
        const p = playerNum === 1 ? state.p1 : state.p2;
        p.angle = Math.atan2(dy, dx);
    }

    function endInput() {
        if (!input.active) return;
        input.active = false;
        
        const dx = input.startX - input.currX;
        const dy = input.startY - input.currY;
        const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 20);
        
        if (power > 2) {
            const p = playerNum === 1 ? state.p1 : state.p2;
            const ball = {
                x: p.x + Math.cos(p.angle) * 35,
                y: p.y - 10 + Math.sin(p.angle) * 35,
                vx: Math.cos(p.angle) * power,
                vy: Math.sin(p.angle) * power,
                age: 0
            };
            state.ball = ball;
            conn.send({ type: 'FIRE', ball: ball });
        }
    }

    function update() {
        // 파티클 업데이트
        particles = particles.filter(p => {
            p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life -= 0.02;
            return p.life > 0;
        });

        if (!state.ball) return;

        const b = state.ball;
        b.vx += state.wind;
        b.vy += GRAVITY;
        b.x += b.vx;
        b.y += b.vy;
        b.age++;

        const groundY = getTerrainHeight(b.x);
        const distP1 = Math.sqrt((b.x - state.p1.x)**2 + (b.y - (state.p1.y - 10))**2);
        const distP2 = Math.sqrt((b.x - state.p2.x)**2 + (b.y - (state.p2.y - 10))**2);

        // 자폭 방지: 발사 후 초기 프레임 동안은 본인 충돌 무시
        let hitP1 = distP1 < 20;
        let hitP2 = distP2 < 20;
        if (b.age < 10) {
            if (state.turn === 1) hitP1 = false;
            else hitP2 = false;
        }

        if (b.y > groundY || hitP1 || hitP2 || b.x < 0 || b.x > w) {
            createExplosion(b.x, b.y);
            
            if (isHost) {
                // 데미지 계산 (직격 또는 스플래시)
                const dmg1 = calculateSplashDamage(b.x, b.y, state.p1.x, state.p1.y - 10);
                const dmg2 = calculateSplashDamage(b.x, b.y, state.p2.x, state.p2.y - 10);
                
                state.p1.hp = Math.max(0, state.p1.hp - dmg1);
                state.p2.hp = Math.max(0, state.p2.hp - dmg2);

                if (state.p1.hp <= 0 || state.p2.hp <= 0) {
                    state.gameOver = true;
                }

                state.ball = null;
                if (!state.gameOver) {
                    state.turn = state.turn === 1 ? 2 : 1;
                    state.wind = (Math.random() - 0.5) * 0.4;
                }
                sendSync();
                showTurnMessage();
            } else {
                state.ball = null;
            }
        }
    }

    function calculateSplashDamage(bx, by, px, py) {
        const d = Math.sqrt((bx - px)**2 + (by - py)**2);
        if (d < 20) return 40; // 직격
        if (d < EXPLOSION_RADIUS) return Math.floor(30 * (1 - d / EXPLOSION_RADIUS));
        return 0;
    }

    function createExplosion(x, y) {
        for (let i = 0; i < 30; i++) {
            particles.push({
                x, y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1,
                color: `rgb(255, ${Math.random() * 150 + 50}, 0)`
            });
        }
    }

    function draw() {
        ctx.clearRect(0, 0, w, h);

        // 지형 그리기
        if (state.terrain) {
            ctx.beginPath();
            ctx.moveTo(0, h);
            state.terrain.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.lineTo(w, h);
            ctx.closePath();
            const grad = ctx.createLinearGradient(0, h * 0.5, 0, h);
            grad.addColorStop(0, '#334155');
            grad.addColorStop(1, '#0f172a');
            ctx.fillStyle = grad;
            ctx.fill();
            
            // 지형 윤곽선
            ctx.beginPath();
            state.terrain.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 3;
            ctx.stroke();
        }

        // 탱크 그리기
        drawTank(state.p1, varColor('--p1-color'), state.turn === 1);
        drawTank(state.p2, varColor('--p2-color'), state.turn === 2);

        // 포탄 그리기
        if (state.ball) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.arc(state.ball.x, state.ball.y, 5, 0, Math.PI * 2);
            ctx.fill();
        }

        // 가이드 라인 (내 차례일 때만)
        if (input.active) {
            drawGuide();
        }

        // 파티클
        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.fillRect(p.x, p.y, 4, 4);
        });
        ctx.globalAlpha = 1;
    }

    function drawTank(p, color, isTurn) {
        ctx.save();
        ctx.translate(p.x, p.y);
        
        // 포신
        ctx.strokeStyle = color;
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(Math.cos(p.angle) * 30, -10 + Math.sin(p.angle) * 30);
        ctx.stroke();

        // 몸체
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.roundRect(-20, -10, 40, 15, 5);
        ctx.fill();
        
        // 포탑
        ctx.beginPath();
        ctx.arc(0, -10, 10, Math.PI, 0);
        ctx.fill();

        // 현재 차례 표시
        if (isTurn && !state.gameOver) {
            ctx.fillStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(-5, -35);
            ctx.lineTo(5, -35);
            ctx.lineTo(0, -25);
            ctx.fill();
        }

        ctx.restore();
    }

    function drawGuide() {
        const p = playerNum === 1 ? state.p1 : state.p2;
        const dx = input.startX - input.currX;
        const dy = input.startY - input.currY;
        const power = Math.min(Math.sqrt(dx*dx + dy*dy) * 0.15, 20);
        
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        
        let tx = p.x + Math.cos(p.angle) * 35;
        let ty = p.y - 10 + Math.sin(p.angle) * 35;
        let tvx = Math.cos(p.angle) * power;
        let tvy = Math.sin(p.angle) * power;
        
        ctx.moveTo(tx, ty);
        for (let i = 0; i < 30; i++) {
            tvx += state.wind;
            tvy += GRAVITY;
            tx += tvx;
            ty += tvy;
            ctx.lineTo(tx, ty);
        }
        ctx.stroke();
        ctx.setLineDash([]);
    }

    function updateUI() {
        document.getElementById('hp1').style.width = (state.p1.hp / MAX_HP * 100) + '%';
        document.getElementById('hp2').style.width = (state.p2.hp / MAX_HP * 100) + '%';
        document.getElementById('wind-indicator').innerText = `WIND: ${Math.abs(state.wind * 100).toFixed(1)} ${state.wind > 0 ? '→' : '←'}`;
        
        if (state.gameOver) {
            const winner = state.p1.hp > 0 ? "BLUE WINS!" : "RED WINS!";
            const msg = document.getElementById('turn-msg');
            msg.innerText = winner;
            msg.style.color = state.p1.hp > 0 ? 'var(--p1-color)' : 'var(--p2-color)';
            msg.classList.add('show');
        }
    }

    function showTurnMessage() {
        if (state.gameOver) return;
        const msg = document.getElementById('turn-msg');
        msg.innerText = state.turn === playerNum ? "YOUR TURN" : "ENEMY TURN";
        msg.style.color = state.turn === playerNum ? 'var(--accent)' : 'white';
        msg.classList.add('show');
        setTimeout(() => msg.classList.remove('show'), 2000);
    }

    function varColor(name) {
        return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
    }

    function gameLoop() {
        update();
        draw();
        requestAnimationFrame(gameLoop);
    }

</script>
</body>
</html>
